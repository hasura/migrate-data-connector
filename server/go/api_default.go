/*
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"io"
	"encoding/json"
	"net/http"
	"time"

	_ "github.com/lib/pq"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type ConnectionStrings struct {
	PostgreSQL_URL	string
	MongoDB_URL	string
}

type Artist struct {
	ArtistId int
	Name	string
}

func queryArtistByIdFromPostgreSQL(connStr, artistId string) error {
	db, err := sql.Open("postgres", connStr)
	if err != nil {
			return err
	}
	defer db.Close()

	row := db.QueryRow("SELECT * FROM Artist WHERE ArtistId = $1", artistId)
	artist := Artist{}
	err = row.Scan(artist)
	if err != nil {
			return err
	}

	return nil
}

func insertArtistInPostgresSQL(connStr, name string) error {
	db, err := sql.Open("postgres", connStr)
	if err != nil {
			return err
	}
	defer db.Close()

	sStmt := "INSERT INTO Artist (name) VALUES ($1)"
	stmt, err := db.Prepare(sStmt)
	if err != nil {
			return err
	}
	defer stmt.Close()

	res, err := stmt.Exec(name)
	if err != nil {
			return err
	}
	if res == nil {
			// what to say? error?
			return errors.New("response can't be nil")
	}
	
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}
	fmt.Println("last inserted id in PostgreSQL", id)

	return nil
}

func insertArtistInMongoDB(connStr, name string, artistId int) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	client, err := mongo.Connect(ctx, options.Client().ApplyURI(connStr))
	defer func() {
			if err = client.Disconnect(ctx); err != nil {
					fmt.Println("error in disconnecting from MongoDB: ", err)
			}
	}()
	collection := client.Database("chinook").Collection("artist")
	ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	_, err = collection.InsertOne(ctx, bson.D{{"Name", name}, {"ArtistId", artistId}})
	if err != nil {
			return err
	}
	return nil
}

func CapabilitiesGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	response := `{
		"capabilities": {
		  "queries": {
			"foreach": {}
		  },
		  "data_schema": {
			"supports_primary_keys": true,
			"supports_foreign_keys": true,
			"column_nullability": "nullable_and_non_nullable"
		  },
		  "relationships": {},
		  "scalar_types": {
			"DateTime": {"comparison_operators": {"in_year": "Number"}}
		  },
		  "user_defined_functions": {}
		},
		"config_schemas": {
		  "config_schema": {
			"type": "object",
			"nullable": false,
			"properties": {
			  "tables": { "$ref": "#/other_schemas/Tables" },
			  "PostgreSQL_URL": {
				  "nullable": false,
				  "type": "string"
			  },
			  "MongoDB_URL": {
				  "nullable": false,
				  "type": "string"
			  }
			}
		  },
		  "other_schemas": {
			"Tables": {
			  "description": "List of tables to make available in the schema and for querying",
			  "type": "array",
			  "items": { "$ref": "#/other_schemas/TableName" },
			  "nullable": true
			},
			"TableName": {
			  "nullable": false,
			  "type": "string"
			}
		  }
		}
	}`

	io.WriteString(w, response)

	w.WriteHeader(http.StatusOK)
}

func DatasetsClonesCloneNameDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func DatasetsClonesCloneNamePost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func DatasetsTemplatesTemplateNameGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func ExplainPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func HealthGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func MetricsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func MutationPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func QueryPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	val, ok := r.Header["X-Hasura-Dataconnector-Config"]
	if !ok {
		fmt.Println("X-Hasura-Dataconnector-Config not found in headers")
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	data := ConnectionStrings{}

	err := json.Unmarshal([]byte(val[0]), &data)
	if err != nil {
		fmt.Println(err.Error()) 
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	fmt.Println("connection strings: ", data)

	b, err := io.ReadAll(r.Body)
	if err != nil {
		fmt.Println(err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	fmt.Println("request body: ", string(b))

	w.WriteHeader(http.StatusOK)
}

func RawPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func SchemaGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	response := `{
		"tables": [
		  {
			"name": ["Artist"],
			"type": "table",
			"primary_key": ["ArtistId"],
			"description": "Collection of artists of music",
			"columns": [
			  {
				"name": "ArtistId",
				"type": "number",
				"nullable": false,
				"description": "Artist primary key identifier",
				"insertable": true,
				"updatable": false,
				"value_generated": { "type": "auto_increment" }
			  },
			  {
				"name": "Name",
				"type": "string",
				"nullable": true,
				"description": "The name of the artist",
				"insertable": true,
				"updatable": true
			  }
			],
			"insertable": true,
			"updatable": true,
			"deletable": true
		  },
		  {
			"name": ["Album"],
			"type": "table",
			"primary_key": ["AlbumId"],
			"description": "Collection of music albums created by artists",
			"columns": [
			  {
				"name": "AlbumId",
				"type": "number",
				"nullable": false,
				"description": "Album primary key identifier",
				"insertable": true,
				"updatable": false,
				"value_generated": { "type": "auto_increment" }
			  },
			  {
				"name": "Title",
				"type": "string",
				"nullable": false,
				"description": "The title of the album",
				"insertable": true,
				"updatable": true
			  },
			  {
				"name": "ArtistId",
				"type": "number",
				"nullable": false,
				"description": "The ID of the artist that created this album",
				"insertable": true,
				"updatable": true
			  }
			],
			"insertable": true,
			"updatable": true,
			"deletable": true
		  }
		]
	}`

	io.WriteString(w, response)

	w.WriteHeader(http.StatusOK)
}
